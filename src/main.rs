use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;
use std::io::Write;
use std::fmt;

use anyhow::{Context, Result};
use clap::Parser;
use serde::Deserialize;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the TOML configuration file
    #[arg(short, long, default_value = "config.toml")]
    config: PathBuf,

    /// Path to output the generated shell configuration file
    #[arg(short, long)]
    output: Option<PathBuf>,

    /// Target shell (zsh or fish)
    #[arg(short, long, default_value = "zsh")]
    shell: Shell,
}

#[derive(Debug, Clone, clap::ValueEnum)]
enum Shell {
    Zsh,
    Fish,
}

impl fmt::Display for Shell {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Shell::Zsh => write!(f, "Zsh"),
            Shell::Fish => write!(f, "Fish"),
        }
    }
}

#[derive(Debug, Deserialize)]
struct Config {
    exports: Option<HashMap<String, String>>,
    path: Option<PathConfig>,
    aliases: Option<HashMap<String, AliasValue>>,
    plugins: Option<Vec<String>>,
    tools: Option<HashMap<String, ToolConfig>>,
    znap: Option<ZnapConfig>,
    modules: Option<Vec<Module>>,
}

#[derive(Debug, Deserialize)]
struct PathConfig {
    prepend: Option<Vec<String>>,
    append: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum AliasValue {
    Simple(String),
    Complex(ComplexAlias),
}

#[derive(Debug, Deserialize)]
struct ComplexAlias {
    cmd: String,
    #[serde(rename = "if")]
    condition: Option<String>,
}

#[derive(Debug, Deserialize)]
struct ToolConfig {
    enabled: Option<bool>,
    #[serde(rename = "if-file")]
    if_file: Option<String>,
    #[serde(rename = "if-cmd")]
    if_cmd: Option<String>,
    exports: Option<HashMap<String, String>>,
    path: Option<PathConfig>,
    commands: Option<Vec<String>>,
    #[serde(rename = "fish-commands")]
    fish_commands: Option<Vec<String>>,
}

#[derive(Debug, Deserialize)]
struct ZnapConfig {
    custom_path: Option<String>,
}

#[derive(Debug, Deserialize)]
struct Module {
    plugins: Option<Vec<String>>,
    zsh_code: Option<String>,
    fish_code: Option<String>,
}

fn main() -> Result<()> {
    let args = Args::parse();
    
    // Read and parse the TOML configuration
    let config_content = fs::read_to_string(&args.config)
        .with_context(|| format!("Failed to read config file: {:?}", args.config))?;
    
    let config: Config = toml::from_str(&config_content)
        .with_context(|| "Failed to parse TOML configuration")?;
    
    // Generate shell configuration content based on the selected shell
    let content = match args.shell {
        Shell::Zsh => generate_zshrc(&config)?,
        Shell::Fish => generate_fish_config(&config)?,
    };
    
    // If output path is provided, write to file, otherwise print to stdout
    match args.output {
        Some(output_path) => {
            // Write the generated content to the output file
            let mut file = fs::File::create(&output_path)
                .with_context(|| format!("Failed to create output file: {:?}", output_path))?;
            
            file.write_all(content.as_bytes())
                .with_context(|| "Failed to write to output file")?;
            
            println!("Successfully generated {} config at {:?}", args.shell.to_string().to_lowercase(), output_path);
        },
        None => {
            // Print to stdout
            print!("{}", content);
        }
    }
    
    Ok(())
}

fn generate_zshrc(config: &Config) -> Result<String> {
    let mut content = String::new();
    
    // Add header
    content.push_str("# This file was generated by zshrcer\n");
    content.push_str("# Do not edit this file directly\n\n");
    
    // Process sections in order based on the config file structure
    
    // 1. Exports
    if let Some(exports) = &config.exports {
        content.push_str("# Exports\n");
        for (key, value) in exports {
            content.push_str(&format!("export {}={}\n", key, value));
        }
        content.push_str("\n");
    }
    
    // 2. Path configuration
    if let Some(path) = &config.path {
        content.push_str("# Path configuration\n");
        
        if let Some(prepend) = &path.prepend {
            for p in prepend {
                content.push_str(&format!("export PATH={}:$PATH\n", p));
            }
        }
        
        if let Some(append) = &path.append {
            for p in append {
                content.push_str(&format!("export PATH=$PATH:{}\n", p));
            }
        }
        
        content.push_str("\n");
    }
    
    // 3. Aliases
    if let Some(aliases) = &config.aliases {
        content.push_str("# Aliases\n");
        
        for (name, alias) in aliases {
            match alias {
                AliasValue::Simple(cmd) => content.push_str(&format!("alias {}='{}'\n", name, cmd)),
                AliasValue::Complex(complex) => {
                    if let Some(condition) = &complex.condition {
                        content.push_str(&format!("if command -v {} >/dev/null 2>&1; then\n", condition));
                        content.push_str(&format!("  alias {}='{}'\n", name, complex.cmd));
                        content.push_str("fi\n");
                    } else {
                        content.push_str(&format!("alias {}='{}'\n", name, complex.cmd));
                    }
                }
            }
        }
        
        content.push_str("\n");
    }
    
    // 4. Process plugins and modules
    let mut has_plugins = false;
    let mut plugins_list = Vec::new();
    
    // Add top-level plugins if they exist
    if let Some(plugins) = &config.plugins {
        has_plugins = true;
        plugins_list.extend(plugins.clone());
    }
    
    // Process modules in order
    if let Some(modules) = &config.modules {
        // First pass: collect plugins from modules
        for module in modules {
            if let Some(module_plugins) = &module.plugins {
                has_plugins = true;
                plugins_list.extend(module_plugins.clone());
            }
        }
        
        // If we have plugins, set up znap and add them
        if has_plugins {
            content.push_str("# Plugins\n");
            
            // Get znap configuration
            let znap_config = &config.znap;
            
            // Setup znap
            content.push_str("# Setup znap plugin manager\n");
            
            // Use custom path if provided in znap config
            let znap_path = if let Some(znap) = znap_config {
                if let Some(custom_path) = &znap.custom_path {
                    custom_path.clone()
                } else {
                    "$HOME/.znap/zsh-snap/znap.zsh".to_string()
                }
            } else {
                "$HOME/.znap/zsh-snap/znap.zsh".to_string()
            };
            
            // Extract directory from znap_path
            let znap_dir = if znap_path.contains('/') {
                znap_path.rsplit_once('/').unwrap().0.to_string()
            } else {
                "$HOME/.znap".to_string()
            };
            
            content.push_str(&format!("ZNAP_DIR=\"{}\"\n", znap_dir));
            content.push_str(&format!("ZNAP_PATH=\"{}\"\n\n", znap_path));
            
            // Check if znap exists, install if not
            content.push_str("# Install znap if not found\n");
            content.push_str("if [ ! -f \"$ZNAP_PATH\" ]; then\n");
            content.push_str("  echo \"znap not found. Installing znap...\"\n");
            content.push_str(&format!("  mkdir -p \"{}\"\n", znap_dir));
            content.push_str("  git clone --depth 1 -- https://github.com/marlonrichert/zsh-snap.git \"$ZNAP_DIR/zsh-snap\"\n");
            content.push_str("fi\n\n");
            
            // Source znap
            content.push_str("# Source znap\n");
            content.push_str("source \"$ZNAP_PATH\"\n\n");
            
            // Initialize znap
            content.push_str("# Initialize znap\n");
            content.push_str("# Create plugins directory if it doesn't exist\n");
            content.push_str("mkdir -p \"$ZNAP_DIR/_repos\"\n\n");
            
            // Load plugins with znap
            content.push_str("# Load plugins with znap\n");
            for plugin in &plugins_list {
                content.push_str(&format!("znap source {}\n", plugin));
            }
            content.push_str("\n");
        }
        
        // Second pass: add custom code from modules in order
        for module in modules {
            if let Some(zsh_code) = &module.zsh_code {
                content.push_str("# Custom module code\n");
                content.push_str(zsh_code);
                content.push_str("\n\n");
            }
        }
    }
    
    // 5. Tools
    if let Some(tools) = &config.tools {
        content.push_str("# Tools\n");
        
        for (name, tool) in tools {
            // Skip disabled tools
            if let Some(enabled) = tool.enabled {
                if !enabled {
                    continue;
                }
            }
            
            content.push_str(&format!("# Tool: {}\n", name));
            
            // Handle conditions
            let mut has_condition = false;
            let mut condition_start = String::new();
            
            // Handle if-file condition
            if let Some(if_file) = &tool.if_file {
                has_condition = true;
                condition_start = format!("if [ -f {} ]; then", if_file);
            }
            
            // Handle if_cmd condition
            if let Some(if_cmd) = &tool.if_cmd {
                has_condition = true;
                condition_start = format!("command -v {} > /dev/null && {{", if_cmd);
            }
            
            // Start condition block if needed
            if has_condition {
                content.push_str(&format!("{}\n", condition_start));
            }
            
            // Add tool-specific exports
            if let Some(exports) = &tool.exports {
                for (key, value) in exports {
                    if has_condition {
                        content.push_str(&format!("  export {}={}\n", key, value));
                    } else {
                        content.push_str(&format!("export {}={}\n", key, value));
                    }
                }
            }
            
            // Add tool-specific path configuration
            if let Some(path) = &tool.path {
                if let Some(prepend) = &path.prepend {
                    for p in prepend {
                        if has_condition {
                            content.push_str(&format!("  export PATH={}:$PATH\n", p));
                        } else {
                            content.push_str(&format!("export PATH={}:$PATH\n", p));
                        }
                    }
                }
                
                if let Some(append) = &path.append {
                    for p in append {
                        if has_condition {
                            content.push_str(&format!("  export PATH=$PATH:{}\n", p));
                        } else {
                            content.push_str(&format!("export PATH=$PATH:{}\n", p));
                        }
                    }
                }
            }
            
            // Add tool-specific commands - prioritize fish-commands if available
            let has_fish_commands = tool.fish_commands.is_some() && !tool.fish_commands.as_ref().unwrap().is_empty();
            
            if has_fish_commands {
                // Use fish-specific commands if available
                if let Some(fish_commands) = &tool.fish_commands {
                    for cmd in fish_commands {
                        if has_condition {
                            content.push_str(&format!("    {}\n", cmd));
                        } else {
                            content.push_str(&format!("{}\n", cmd));
                        }
                    }
                }
            } else if let Some(commands) = &tool.commands {
                // Fall back to converted zsh commands if no fish commands are specified
                for cmd in commands {
                    // Convert zsh command to fish command
                    let fish_cmd = convert_zsh_to_fish_command(cmd);
                    if has_condition {
                        content.push_str(&format!("    {}\n", fish_cmd));
                    } else {
                        content.push_str(&format!("{}\n", fish_cmd));
                    }
                }
            }
            
            // Close condition block
            if has_condition {
                if tool.if_cmd.is_some() {
                    content.push_str("}\n");
                } else {
                    content.push_str("fi\n");
                }
            }
            
            content.push_str("\n");
        }
    }
    
    Ok(content)
}

fn generate_fish_config(config: &Config) -> Result<String> {
    let mut content = String::new();
    
    // Add header
    content.push_str("# This file was generated by zshrcer\n");
    content.push_str("# Do not edit this file directly\n\n");
    
    // Process sections in order based on the config file structure
    
    // 1. Exports
    if let Some(exports) = &config.exports {
        content.push_str("# Exports\n");
        for (key, value) in exports {
            content.push_str(&format!("set -gx {} {}\n", key, value));
        }
        content.push_str("\n");
    }
    
    // 2. Path configuration
    if let Some(path) = &config.path {
        content.push_str("# Path configuration\n");
        
        if let Some(prepend) = &path.prepend {
            for p in prepend {
                content.push_str(&format!("fish_add_path --prepend {}\n", p));
            }
        }
        
        if let Some(append) = &path.append {
            for p in append {
                content.push_str(&format!("fish_add_path --append {}\n", p));
            }
        }
        
        content.push_str("\n");
    }
    
    // 3. Aliases
    if let Some(aliases) = &config.aliases {
        content.push_str("# Aliases\n");
        
        for (name, alias) in aliases {
            match alias {
                AliasValue::Simple(cmd) => content.push_str(&format!("alias {}='{}'\n", name, cmd)),
                AliasValue::Complex(complex) => {
                    if let Some(condition) = &complex.condition {
                        content.push_str(&format!("if command -v {} >/dev/null 2>&1\n", condition));
                        content.push_str(&format!("    alias {}='{}'\n", name, complex.cmd));
                        content.push_str("end\n");
                    } else {
                        content.push_str(&format!("alias {}='{}'\n", name, complex.cmd));
                    }
                }
            }
        }
        
        content.push_str("\n");
    }
    
    // 4. Process modules
    // Fish doesn't support znap, so we'll skip plugin loading
    // But we'll still process custom code from modules
    
    if let Some(modules) = &config.modules {
        for module in modules {
            // First check if we have fish_code
            if let Some(fish_code) = &module.fish_code {
                content.push_str("# Custom module code (Fish)\n");
                content.push_str(fish_code);
                content.push_str("\n\n");
            } 
            // If no fish_code but we have zsh_code, convert it
            else if let Some(zsh_code) = &module.zsh_code {
                content.push_str("# Custom module code (converted from Zsh)\n");
                // Convert any zsh-specific code to fish-compatible code
                let converted_code = convert_zsh_to_fish_code(zsh_code);
                content.push_str(&converted_code);
                content.push_str("\n\n");
            }
            // Skip plugins section as Fish doesn't use znap
        }
    }
    
    // 5. Tools
    if let Some(tools) = &config.tools {
        content.push_str("# Tools\n");
        
        for (name, tool) in tools {
            // Skip disabled tools
            if let Some(enabled) = tool.enabled {
                if !enabled {
                    continue;
                }
            }
            
            content.push_str(&format!("# Tool: {}\n", name));
            
            // Handle conditions
            let mut has_condition = false;
            let mut condition_start = String::new();
            
            // Handle if-file condition
            if let Some(if_file) = &tool.if_file {
                has_condition = true;
                condition_start = format!("if test -f {}", if_file);
            }
            
            // Handle if_cmd condition
            if let Some(if_cmd) = &tool.if_cmd {
                has_condition = true;
                condition_start = format!("if command -v {} >/dev/null 2>&1", if_cmd);
            }
            
            // Start condition block if needed
            if has_condition {
                content.push_str(&format!("{}\n", condition_start));
            }
            
            // Add tool-specific exports
            if let Some(exports) = &tool.exports {
                for (key, value) in exports {
                    if has_condition {
                        content.push_str(&format!("    set -gx {} {}\n", key, value));
                    } else {
                        content.push_str(&format!("set -gx {} {}\n", key, value));
                    }
                }
            }
            
            // Add tool-specific path configuration
            if let Some(path) = &tool.path {
                if let Some(prepend) = &path.prepend {
                    for p in prepend {
                        if has_condition {
                            content.push_str(&format!("    fish_add_path --prepend {}\n", p));
                        } else {
                            content.push_str(&format!("fish_add_path --prepend {}\n", p));
                        }
                    }
                }
                
                if let Some(append) = &path.append {
                    for p in append {
                        if has_condition {
                            content.push_str(&format!("    fish_add_path --append {}\n", p));
                        } else {
                            content.push_str(&format!("fish_add_path --append {}\n", p));
                        }
                    }
                }
            }
            
            // Add tool-specific commands - prioritize fish-commands if available
            let has_fish_commands = tool.fish_commands.is_some() && !tool.fish_commands.as_ref().unwrap().is_empty();
            
            if has_fish_commands {
                // Use fish-specific commands if available
                if let Some(fish_commands) = &tool.fish_commands {
                    for cmd in fish_commands {
                        if has_condition {
                            content.push_str(&format!("    {}\n", cmd));
                        } else {
                            content.push_str(&format!("{}\n", cmd));
                        }
                    }
                }
            } else if let Some(commands) = &tool.commands {
                // Fall back to converted zsh commands if no fish commands are specified
                for cmd in commands {
                    // Convert zsh command to fish command
                    let fish_cmd = convert_zsh_to_fish_command(cmd);
                    if has_condition {
                        content.push_str(&format!("    {}\n", fish_cmd));
                    } else {
                        content.push_str(&format!("{}\n", fish_cmd));
                    }
                }
            }
            
            // Close condition block
            if has_condition {
                content.push_str("end\n");
            }
            
            content.push_str("\n");
        }
    }
    
    Ok(content)
}

// Helper function to convert zsh code to fish-compatible code
fn convert_zsh_to_fish_code(zsh_code: &str) -> String {
    let mut fish_code = String::new();
    
    for line in zsh_code.lines() {
        let trimmed = line.trim();
        
        // Skip zsh-specific options
        if trimmed.starts_with("setopt") || trimmed.starts_with("unsetopt") {
            fish_code.push_str(&format!("# Fish equivalent not available: {}\n", line));
            continue;
        }
        
        // Convert source commands
        if trimmed.contains("source ") && !trimmed.contains("&&") && !trimmed.contains("||") {
            let fish_line = line.replace("source ", ". ");
            fish_code.push_str(&format!("{}\n", fish_line));
            continue;
        }
        
        // Convert conditional file checks with source
        if (trimmed.contains("[ -f ") || trimmed.contains("test -f ")) && trimmed.contains(" && source ") {
            let parts: Vec<&str> = if trimmed.contains(" && source ") {
                trimmed.split(" && source ").collect()
            } else {
                continue;
            };
            
            if parts.len() == 2 {
                let file_part = parts[0]
                    .replace("[ -f ", "")
                    .replace("test -f ", "")
                    .replace(" ]", "")
                    .trim()
                    .to_string();
                let source_part = parts[1].trim().to_string();
                
                // Indent the line properly
                let indent = line.chars().take_while(|c| c.is_whitespace()).collect::<String>();
                fish_code.push_str(&format!("{}if test -f {}\n", indent, file_part));
                fish_code.push_str(&format!("{}    . {}\n", indent, source_part));
                fish_code.push_str(&format!("{}end\n", indent));
                continue;
            }
        }
        
        // Default: keep the line as is
        fish_code.push_str(&format!("{}\n", line));
    }
    
    fish_code
}

// Helper function to convert zsh commands to fish-compatible commands
fn convert_zsh_to_fish_command(zsh_cmd: &str) -> String {
    // Convert eval commands for common tools
    if zsh_cmd.contains("eval \"$(") && zsh_cmd.contains("init zsh") {
        // Handle common tools that have fish equivalents
        if zsh_cmd.contains("zoxide init zsh") {
            return zsh_cmd.replace("zoxide init zsh", "zoxide init fish");
        } else if zsh_cmd.contains("starship init zsh") {
            return zsh_cmd.replace("starship init zsh", "starship init fish");
        } else if zsh_cmd.contains("mcfly init zsh") {
            return zsh_cmd.replace("mcfly init zsh", "mcfly init fish");
        } else if zsh_cmd.contains("pyenv init -") {
            return "status --is-interactive; and pyenv init - | source".to_string();
        }
    }
    
    // Convert source commands
    if zsh_cmd.starts_with("source ") {
        return zsh_cmd.replace("source ", ". ");
    }
    
    // Convert conditional file checks
    if zsh_cmd.contains("[ -s ") && zsh_cmd.contains(" ] && source ") {
        let parts: Vec<&str> = zsh_cmd.split(" ] && source ").collect();
        if parts.len() == 2 {
            let file_part = parts[0].replace("[ -s ", "").trim().to_string();
            let source_part = parts[1].trim().to_string();
            return format!("if test -s {}\n    . {}\nend", file_part, source_part);
        }
    }
    
    // Default: return the command as is
    zsh_cmd.to_string()
}
