use crate::config::Config;
use anyhow::Result;

pub fn generate_zsh(config: &Config) -> Result<String> {
    let mut output = String::new();
    
    // Header
    output.push_str("#!/usr/bin/env zsh\n\n");
    output.push_str("# This file was generated by shrcer\n");
    output.push_str("# Do not edit this file directly; modify the config.toml file instead\n\n");
    
    // Process modules
    for module in &config.modules {
        if !module.zsh_code.is_empty() {
            output.push_str(&module.zsh_code);
            output.push_str("\n\n");
        }
    }
    
    // Process exports
    if !config.exports.common.is_empty() || !config.exports.zsh.is_empty() {
        output.push_str("# Environment variables\n");
        
        for (key, value) in &config.exports.common {
            output.push_str(&format!("export {}={}\n", key, value));
        }
        
        for (key, value) in &config.exports.zsh {
            output.push_str(&format!("export {}={}\n", key, value));
        }
        
        output.push('\n');
    }
    
    // Process path configuration
    if !config.path.prepend.is_empty() || !config.path.append.is_empty() {
        output.push_str("# Path configuration\n");
        
        for path in &config.path.prepend {
            output.push_str(&format!("export PATH={}:$PATH\n", path));
        }
        
        for path in &config.path.append {
            output.push_str(&format!("export PATH=$PATH:{}\n", path));
        }
        
        output.push('\n');
    }
    
    // Process aliases
    if !config.aliases.is_empty() {
        output.push_str("# Aliases\n");
        
        for (alias, config) in &config.aliases {
            if let Some(if_tool) = &config.if_tool {
                output.push_str(&format!("if command -v {} &>/dev/null; then\n", if_tool));
                output.push_str(&format!("  alias {}='{}'\n", alias, config.cmd));
                output.push_str("fi\n");
            } else if let Some(if_condition) = &config.if_condition {
                output.push_str(&format!("if [[ {} ]]; then\n", if_condition));
                output.push_str(&format!("  alias {}='{}'\n", alias, config.cmd));
                output.push_str("fi\n");
            } else {
                output.push_str(&format!("alias {}='{}'\n", alias, config.cmd));
            }
        }
        
        output.push('\n');
    }
    
    // Process znap configuration if present
    if let Some(znap_config) = &config.znap {
        output.push_str("# Znap configuration\n");
        output.push_str(&format!("[ -f {} ] && source {}\n\n", znap_config.custom_path, znap_config.custom_path));
        
        // Process plugins if znap is configured
        let has_plugins = config.modules.iter().any(|m| !m.plugins.is_empty());
        
        if has_plugins {
            output.push_str("# Plugins\n");
            
            for module in &config.modules {
                for plugin in &module.plugins {
                    let plugin_parts: Vec<&str> = plugin.split('/').collect();
                    if plugin_parts.len() == 2 {
                        output.push_str(&format!("znap source {}\n", plugin));
                    }
                }
            }
            
            output.push('\n');
        }
    }
    
    // Process tool configurations
    if !config.tools.is_empty() {
        output.push_str("# Tool configurations\n");
        
        for (tool_name, tool_config) in &config.tools {
            let mut skip = false;
            
            if let Some(if_cmd) = &tool_config.if_cmd {
                output.push_str(&format!("if command -v {} &>/dev/null; then\n", if_cmd));
            } else if let Some(if_file) = &tool_config.if_file {
                output.push_str(&format!("if [ -f {} ]; then\n", if_file));
            } else {
                skip = true;
            }
            
            if !skip {
                // Process exports for this tool
                for (key, value) in &tool_config.exports {
                    output.push_str(&format!("  export {}={}\n", key, value));
                }
                
                // Process path for this tool
                for path in &tool_config.path.prepend {
                    output.push_str(&format!("  export PATH={}:$PATH\n", path));
                }
                
                for path in &tool_config.path.append {
                    output.push_str(&format!("  export PATH=$PATH:{}\n", path));
                }
                
                // Add tool-specific code
                if !tool_config.zsh_code.is_empty() {
                    output.push_str(&format!("  {}\n", tool_config.zsh_code));
                }
                
                output.push_str("fi\n");
            } else {
                // No condition, just add the code directly
                if !tool_config.exports.is_empty() || !tool_config.path.prepend.is_empty() || 
                   !tool_config.path.append.is_empty() || !tool_config.zsh_code.is_empty() {
                    output.push_str(&format!("# {} configuration\n", tool_name));
                    
                    // Process exports for this tool
                    for (key, value) in &tool_config.exports {
                        output.push_str(&format!("export {}={}\n", key, value));
                    }
                    
                    // Process path for this tool
                    for path in &tool_config.path.prepend {
                        output.push_str(&format!("export PATH={}:$PATH\n", path));
                    }
                    
                    for path in &tool_config.path.append {
                        output.push_str(&format!("export PATH=$PATH:{}\n", path));
                    }
                    
                    // Add tool-specific code
                    if !tool_config.zsh_code.is_empty() {
                        output.push_str(&format!("{}\n", tool_config.zsh_code));
                    }
                }
            }
            
            output.push('\n');
        }
    }
    
    Ok(output)
}

pub fn generate_fish(config: &Config) -> Result<String> {
    let mut output = String::new();
    
    // Header
    output.push_str("#!/usr/bin/env fish\n\n");
    output.push_str("# This file was generated by shrcer\n");
    output.push_str("# Do not edit this file directly; modify the config.toml file instead\n\n");
    
    // Process modules
    for module in &config.modules {
        if !module.fish_code.is_empty() {
            output.push_str(&module.fish_code);
            output.push_str("\n\n");
        }
    }
    
    // Process exports
    if !config.exports.common.is_empty() || !config.exports.fish.is_empty() {
        output.push_str("# Environment variables\n");
        
        for (key, value) in &config.exports.common {
            output.push_str(&format!("set -gx {} {}\n", key, value));
        }
        
        for (key, value) in &config.exports.fish {
            output.push_str(&format!("set -gx {} {}\n", key, value));
        }
        
        output.push('\n');
    }
    
    // Process path configuration
    if !config.path.prepend.is_empty() || !config.path.append.is_empty() {
        output.push_str("# Path configuration\n");
        
        for path in &config.path.prepend {
            output.push_str(&format!("fish_add_path --prepend {}\n", path));
        }
        
        for path in &config.path.append {
            output.push_str(&format!("fish_add_path --append {}\n", path));
        }
        
        output.push('\n');
    }
    
    // Process aliases (fish uses functions instead of aliases)
    if !config.aliases.is_empty() {
        output.push_str("# Aliases\n");
        
        for (alias, config) in &config.aliases {
            if let Some(if_tool) = &config.if_tool {
                output.push_str(&format!("if command -q {}\n", if_tool));
                output.push_str(&format!("  function {} --wraps {}\n", alias, config.cmd));
                output.push_str(&format!("    {} $argv\n", config.cmd));
                output.push_str("  end\n");
                output.push_str("end\n");
            } else if let Some(if_condition) = &config.if_condition {
                output.push_str(&format!("if test {}\n", if_condition));
                output.push_str(&format!("  function {} --wraps {}\n", alias, config.cmd));
                output.push_str(&format!("    {} $argv\n", config.cmd));
                output.push_str("  end\n");
                output.push_str("end\n");
            } else {
                output.push_str(&format!("function {} --wraps {}\n", alias, config.cmd));
                output.push_str(&format!("  {} $argv\n", config.cmd));
                output.push_str("end\n");
            }
        }
        
        output.push('\n');
    }
    
    // Process tool configurations
    if !config.tools.is_empty() {
        output.push_str("# Tool configurations\n");
        
        for (tool_name, tool_config) in &config.tools {
            let mut skip = false;
            
            if let Some(if_cmd) = &tool_config.if_cmd {
                output.push_str(&format!("if command -q {}\n", if_cmd));
            } else if let Some(if_file) = &tool_config.if_file {
                output.push_str(&format!("if test -f {}\n", if_file));
            } else {
                skip = true;
            }
            
            if !skip {
                // Process exports for this tool
                for (key, value) in &tool_config.exports {
                    output.push_str(&format!("  set -gx {} {}\n", key, value));
                }
                
                // Process path for this tool
                for path in &tool_config.path.prepend {
                    output.push_str(&format!("  fish_add_path --prepend {}\n", path));
                }
                
                for path in &tool_config.path.append {
                    output.push_str(&format!("  fish_add_path --append {}\n", path));
                }
                
                // Add tool-specific code
                if !tool_config.fish_code.is_empty() {
                    output.push_str(&format!("  {}\n", tool_config.fish_code));
                }
                
                output.push_str("end\n");
            } else {
                // No condition, just add the code directly
                if !tool_config.exports.is_empty() || !tool_config.path.prepend.is_empty() || 
                   !tool_config.path.append.is_empty() || !tool_config.fish_code.is_empty() {
                    output.push_str(&format!("# {} configuration\n", tool_name));
                    
                    // Process exports for this tool
                    for (key, value) in &tool_config.exports {
                        output.push_str(&format!("set -gx {} {}\n", key, value));
                    }
                    
                    // Process path for this tool
                    for path in &tool_config.path.prepend {
                        output.push_str(&format!("fish_add_path --prepend {}\n", path));
                    }
                    
                    for path in &tool_config.path.append {
                        output.push_str(&format!("fish_add_path --append {}\n", path));
                    }
                    
                    // Add tool-specific code
                    if !tool_config.fish_code.is_empty() {
                        output.push_str(&format!("{}\n", tool_config.fish_code));
                    }
                }
            }
            
            output.push('\n');
        }
    }
    
    Ok(output)
} 